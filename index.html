<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="/node_modules/phaser/dist/phaser.js"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <script>
    const gameId = (t = new URLSearchParams(window.location.search)).get('game') || 0;

    fetch(`api/games/${gameId}`).then(response => response.json()).then(function({ mapId, objects }) {
      fetch(`api/maps/${mapId}`).then(response => response.json()).then(function({ image, width, height, cellSize }) {
        start(image, width, height, cellSize, objects);
      });
    });

    function start(image, width, height, cellSize, objects) {
      let config = {
        type: Phaser.AUTO,
        physics: {
          default: 'arcade'
        },
        width,
        height,
        scene: {
          preload,
          create
        }
      };

      let game = new Phaser.Game(config);

      function preload () {
        this.load.setBaseURL('/assets');

        this.load.image('map', image);
        objects.forEach(({ name, image }) => {
          this.load.image(name, image);
        });

        this.data.set('socket', io.connect());
      }
    
      function create () {
        let socket = this.data.get('socket');

        // Drawing the map
        this.add.image(width / 2, height / 2, 'map');

        // Drawing the grid
        let outlineFillColor = '0x000000';
        let outlineFillOpacity = 0.1;
        this.add.grid(
          width / 2, height / 2, // position
          width, height,
          cellSize, cellSize,
          null, null, // fill
          outlineFillColor, outlineFillOpacity
        );

        // Drawing objects
        objects.forEach(({ name, x, y }) => {
          let { x: x1, y: y1 } = getCellPosition({ x, y }, cellSize);
          this.add.image(x1, y1, name)
            .setDisplaySize(cellSize, cellSize);
        });

        // Drawing hover cell
        let hoverCell = this.add.rectangle(0, 0, cellSize, cellSize, '0x000000', 0.3);

        // Updating hover cell on socket receiving data
        socket.on('hoverCell', function(position) {
          let { x, y } = getCellPosition(position, cellSize);
          hoverCell.setPosition(x, y);
          updateHoverCell(game, hoverCell, position, cellSize);
        });

        // Updating hover cell on mouse move
        this.input.on('pointermove', function (pointer) {
          let matchingCell = getMatchingCell(pointer, cellSize);

          updateHoverCell(this, hoverCell, matchingCell, cellSize, function() {
            socket.emit('hoverCell', matchingCell);
          })
        }, this);
      }  
    }

    function updateHoverCell(game, hoverCell, position, cellSize, callback) {
      if (!positionEquals(position, game.data.get('hoverCellPosition'))) {
        let { x, y } = getCellPosition(position, cellSize);
        hoverCell.setPosition(x, y);
        game.data.set('hoverCellPosition', position);
        if (callback) {
          callback();
        }
      }
    }

    function positionEquals(p1, p2 ) {
      return p1 && p2 && p1.x === p2.x && p1.y === p2.y;
    }

    function getMatchingCell({ x, y }, cellSize) {
      return {
        x: Math.floor(x / cellSize),
        y: Math.floor(y / cellSize)
      }
    }

    function getCellPosition({ x, y }, cellSize) {
      return {
        x: Math.round(x * cellSize + cellSize / 2),
        y: Math.round(y * cellSize + cellSize / 2)
      }
    }
  </script>
</body>
</html>